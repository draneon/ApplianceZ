<?php

class Application_Model_NetworkConfigMapper
{
	const NETWORK_IFACES_PATH = '/etc/network/interfaces';
    const RESOLVE_CONF_PATH = '/etc/resolv.conf';
    const HOSTS_PATH = '/etc/hosts';

    const EXTERNAL_IFACE = 'eth0';

    const AUTOGEN_WARNING = "# This file was generated by the Novarad DICOM router configuration page and could be overwritten by it if changes to the configuration are made\n";

	public static function load() {
        $config = new Application_Model_NetworkConfig();

        $routes = `ip route list`;
        if (!preg_match('|eth0.+src\s+([0-9.]+).+via\s+([0-9.]+)|ms', $routes, $matches) || count($matches) != 3) {
            return null;
        }

        $isDhcp = strlen(shell_exec('grep "'.self::EXTERNAL_IFACE.'.*dhcp" '.self::NETWORK_IFACES_PATH)) > 0;
        $config->setIpMode($isDhcp ? Application_Model_NetworkConfig::IpMode_Dhcp : Application_Model_NetworkConfig::IpMode_Static);
        $config->setIpAddress($matches[1]);
        $config->setGateway($matches[2]);

        $ifconf = `/sbin/ifconfig eth0`;
        if (!preg_match('|Mask:([0-9.]+)|ms', $ifconf, $matches) || count($matches) != 2) {
            return null;
        }
        
        $config->setNetmask($matches[1]);

        $config->setHostname(trim(`hostname`));
        self::loadDomainName($config);

        preg_match_all('|nameserver\s+([0-9.]+)|', file_get_contents(self::RESOLVE_CONF_PATH), $matches);
        if (count($matches) == 2) {
            $config->setNameservers($matches[1]);
        }

        return $config;
	}

    public static function loadDomainName($config) {
        $config->setDomain(trim(`dnsdomainname`));
    }


	public static function save(Application_Model_NetworkConfig $config) {
        self::writeInterfaces($config);
        self::writeNameservers($config);
        self::writeHostname($config);
	}

    public static function writeInterfaces(Application_Model_NetworkConfig $config) {
        $file = self::AUTOGEN_WARNING . <<<EOT
auto lo
iface lo inet loopback
auto eth0

EOT;
        $file .= 'iface eth0 inet ';
        $mode = $config->getIpMode();
        switch ($mode) {
        case Application_Model_NetworkConfig::IpMode_Dhcp:
            $file .= "dhcp\n";
            break;
        case Application_Model_NetworkConfig::IpMode_Static:
            $file .= "static\n";
            $file .= "address ".$config->getIpAddress()."\n".
                     "netmask ".$config->getNetmask()."\n".
                     "gateway ".$config->getGateway()."\n";
            break;
        default:
            throw new exception('unknown ip mode');
        }

        file_put_contents(self::NETWORK_IFACES_PATH, $file);
    }

    public static function writeNameservers(Application_Model_NetworkConfig $config) {
        if ($config->getIpMode() == Application_Model_NetworkConfig::IpMode_Static) {
            $file = self::AUTOGEN_WARNING;
            $file .= "domain ".$config->getDomain()."\n".
                     "search ".$config->getDomain()."\n";
            foreach ($config->getNameservers() as $ns) {
                $file .= "nameserver ".$ns."\n";
            }
            file_put_contents(self::RESOLVE_CONF_PATH, $file);
        }
    }

    public static function writeHostname(Application_Model_NetworkConfig $config) {
        // not being able to resolve our own hostname makes some things really slow, so rewrite hosts file
        $file = self::AUTOGEN_WARNING;
        $file .= "127.0.0.1\tlocalhost\n".
                "127.0.1.1\t".$config->getHostname().'.'.$config->getDomain()."\t".$config->getHostname()."\n";
        $file .= <<< EOT

# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters

EOT;
        file_put_contents(self::HOSTS_PATH, $file);

        exec("sudo hostname ".$config->getHostname());

    }

    public static function applyNetworkingChanges() {
        passthru("sudo /etc/init.d/networking restart");
    }

}
